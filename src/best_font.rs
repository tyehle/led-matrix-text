use heapless::consts::*;
use heapless::*;

type Letter = [&'static [u8]; 8];

fn get_alphabet() -> Result<FnvIndexMap<char, Letter, U32>, &'static str> {
    let mut alphabet: FnvIndexMap<char, Letter, U32> = heapless::FnvIndexMap::new();

    alphabet
        .insert(
            'H',
            [
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0xF, 0xF, 0xF, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
            ],
        )
        .map_err(|_| "no space")?;

    alphabet
        .insert(
            ' ',
            [
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
            ],
        )
        .map_err(|_| "no space")?;

    alphabet
        .insert(
            'e',
            [
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0xF, 0xF, 0xF, 0x0],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0xF, 0xF, 0xF, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0xF, 0xF, 0xF, 0xF],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
            ],
        )
        .map_err(|_| "no space")?;


    alphabet
        .insert(
            'l',
            [
                &[0x0, 0xF, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0xF, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
            ],
        )
        .map_err(|_| "no space")?;


    alphabet
        .insert(
            'o',
            [
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0xF, 0xF, 0xF, 0x0],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0xF, 0x0, 0x0, 0x0, 0xF],
                &[0x0, 0xF, 0xF, 0xF, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
            ],
        )
        .map_err(|_| "no space")?;

    alphabet
        .insert(
            'i',
            [
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0xF, 0x0, 0x0],
                &[0x0, 0x0, 0x0, 0x0, 0x0],
            ],
        )
        .map_err(|_| "no space")?;

    alphabet
        .insert(
            '\u{1f}',
            [
                &[0x0],
                &[0x0],
                &[0x0],
                &[0x0],
                &[0x0],
                &[0x0],
                &[0x0],
                &[0x0],
            ],
        )
        .map_err(|_| "no space")?;

    Ok(alphabet)
}

pub fn spell(word: &str, buffer: &mut [&mut [u8]; 8]) -> Result<(), &'static str> {
    let alphabet = get_alphabet()?;

    let mut offset = 0;
    for chr in word.chars() {
        let image = alphabet.get(&chr).ok_or("Unknown letter")?;
        let image_width = image[0].len();
        // make sure we have enough room in the output
        if offset + image_width >= buffer[0].len() {
            return Err("buffer not long enough");
        }

        for row in 0..buffer.len() {
            for col in 0..image_width {
                buffer[row][offset + col] = image[row][col];
            }
        }
        offset += image_width;
    }

    Ok(())
}
